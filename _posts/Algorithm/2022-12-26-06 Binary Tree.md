---
title: "[Lecture Summary] 06 Algorithm and Data Structure : Binary Tree"
toc: true
toc_sticky: true
toc_lable: "Main Contents"
use_math: true
categories:
  - Algorithm
tags:
  - [Algorithm, DataStructure]
---

This contents is based on Lecture of [link](https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/pages/syllabus/)

# Overview

![제목](/assets/images/algorithm/6-0.PNG){: width="70%" height="55%"}{: .align-center}

For any kind of Interface, we'd like to acheive efficient, logartihm time scale! This means that any operation on data structure achieve averagely beneficial.

So we suggest **binary tree** structure.

One thing is that linked list can be considered as a kind of tree structure but its node has only 2 pointers which are pointing previous and next one.<br>
Therefore, depth of linked list is linear which makes opeartion linear time.

However, binary tree is also pointer-based data structure with tree pointers which are parents, left and right pointers.<br>
This can improve into logarithm time scale being depth of $\log(n)$.

## Flow

First of all, all the operation takes time proportional to the height of binary tree.<br>
Then prove it that height is logartime time.<br>
Finally, how to assure, or maintain, height is logarithm to the number of nodes(balanced)!

## Properties to keep in mind!

> Subtree_augmentation
  each node can store $O(1)$ extra field or properties

> subtree property
  anything which can be computed from properties of **node's children**(or node itself, **bottom up** order!) in $O(1)$ time.<br>
  Ex: node.size $\gets$ node.left.size + node.right.size + 1<br>
  Therefore we can update properties dynamically!


# Terminology

Depth of node $x$
- \# of ancestors
- \# of edges in path from $x$ up to the root
- (Personally) upward length

Height of node $x$
- \# of edges in the **longest** downward path from $x$
  - all leaves have zero height
- math depth of any node in the subtree rooted at node $x$

Size of node $x$
- \# of nodes in subtree($x$) including $x$

Traversal order of binary tree
- It is intrinsic(implicit) order
  - No need to manipulating order array(If you want to make, takes linear time! OOPS!). Tree structure already implies it.
- For node $x$, at the left hand side of it, its predecessor exist and at the right hand side of it, its successor exist.
- Every node in left(right) subtree of node $x$ is before(after) $x$ in this order.
- THEN, we can define in a **recursive equation** starting from root(**top down**)

--- ---

# Operations

def subtree(node $x$):
- (interface) return subtree rooted at node $x$
  - including node $x$

def subtree_first(node $x$):
- (interface) return node in subtree among subtree($x$) which comes first in a traversal order
- (algorithm) 
  - update node $\gets$ node.left util falling off tree(which is node.left = None) 
  - return node
- Takes $O(h)$!(because it can reach leaf in the worst case)

def successor/predecessor(node $x$):
- (interface) return next/before node in a traveral order
- (algorithm) 
  - if $x$.right/$x$.left exist, return subtree_first($x$.right/$x$.left)
  - else 
    - update node $\gets$ node.parrent until x is in left/right subtree
    - return subtree_first(node)
- Takes $O(h)$!(because it can reach leaf in the worst case)

def subtree_insert_after(node $x$, node_new $y$):
- (interace) inters new node $y$ after node $x$
- (algorithm) 
  - if x.right does not exist, x.right = y
  - else successor(x).left = y
- Takes $O(h)$!(because it uses successor())

def subtree_delete(node $x$):
- (interface) remove $x$ from its subtree(or traversal order)
- (algorithm)
  - if x is leaf, x.parrent.dirrection = None
  - else if x.left exist(or predecessor($x$) is not None)
    - swap $x$.item & predecessor($x$).item
    - subtree_delete(predecessor($x$))
- Takes $O(h)$ because of function predecessor($\cdot$)

# Set Interface: Set Binary Tree, Binary Search Tree(BST)

The thing is that  **traversal order is same with increasing order of item.key**.<br>
This is **BST Property** which is satisfying following relation<br>
- every key in left subtree $\le$ node's key $\le$ every key in right subtree.

THEN, finding operation is **binary search** which takes $O(h)$!.

## Operation for Set Interface

Operation to support is insert/deleter! 

# Sequence Interface: Sequence Binary Tree

**traversal order is same with sequence order**


